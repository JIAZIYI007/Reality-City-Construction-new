plugins {
    id "com.github.johnrengelman.shadow"
}

loom {
}

repositories {
    maven { url = 'https://maven.neoforged.net/releases' }
}

architectury {
    platformSetupLoomIde()
    neoForge {
        platformPackage = "forge"
        remapForgeLike "net/minecraftforge/common/extensions/IForgeItem", "net/neoforged/neoforge/common/extensions/IItemExtension"
        remapForgeLike "net/minecraftforge/client/event/TextureStitchEvent\$Post", "net/neoforged/neoforge/client/event/TextureAtlasStitchedEvent"
        remapForgeLike "net/minecraftforge/fluids/ForgeFlowingFluid", "net/neoforged/neoforge/fluids/BaseFlowingFluid"
        remapForgeLike "net/minecraftforge/fluids/ForgeFlowingFluid\$Properties", "net/neoforged/neoforge/fluids/BaseFlowingFluid\$Properties"
        remapForgeLike "net/minecraftforge/common/ForgeHooks", "net/neoforged/neoforge/common/CommonHooks"
    }
}

configurations {
    common
    forgeLike
    shadowCommon // Don't use shadow from the shadow plugin because we don't want IDEA to index this.
    compileClasspath.extendsFrom common, forgeLike
    runtimeClasspath.extendsFrom common, forgeLike
    developmentNeoForge.extendsFrom common
    developmentForgeLike.extendsFrom forgeLike
}

dependencies {
    neoForge "net.neoforged:neoforge:${rootProject.ext.neo_forge_version}"

    common(project(path: ":common", configuration: "namedElements")) { transitive false }
    forgeLike(project(path: ":forge", configuration: "namedElements")) { transitive false }
    shadowCommon(project(path: ":common", configuration: "transformProductionNeoForge")) { transitive false }
    shadowCommon(project(path: ":forge", configuration: "transformProductionNeoForge")) { transitive false }
}

processResources {
    filesMatching("META-INF/mods.toml") {
        expand "version": project.version
    }
    inputs.property "META-INF/mods.toml", project.version
}

shadowJar {
    exclude "fabric.mod.json"
    exclude "architectury-common.accessWidener"
    exclude "architectury.common.json"

    configurations = [project.configurations.shadowCommon]
    archiveClassifier = "dev-shadow"

    // Replace classes with forge's version
    exclude "dev/architectury/core/block/ArchitecturyLiquidBlock.class"
    exclude "dev/architectury/core/fluid/ArchitecturyFlowingFluid.class"
    exclude 'dev/architectury/core/fluid/ArchitecturyFlowingFluid$Source.class'
    exclude 'dev/architectury/core/fluid/ArchitecturyFlowingFluid$Flowing.class'
    exclude 'dev/architectury/core/item/ArchitecturyBucketItem.class'
    exclude 'dev/architectury/core/item/ArchitecturyMobBucketItem.class'
    relocate "dev.architectury.core.block.forge.imitator", "dev.architectury.core.block"
    relocate "dev.architectury.core.fluid.forge.imitator", "dev.architectury.core.fluid"
    relocate "dev.architectury.core.item.forge.imitator", "dev.architectury.core.item"
}

remapJar {
    input.set shadowJar.archiveFile
    dependsOn shadowJar
    archiveClassifier = null
    atAccessWideners.add "architectury.accessWidener"
}

task renameJarForPublication(type: Zip, dependsOn: remapJar) {
    from remapJar.archiveFile.map { zipTree(it) }
    archiveExtension = "jar"
    metadataCharset "UTF-8"
    destinationDirectory = base.libsDirectory
    archiveClassifier = project.name
}

assemble.dependsOn renameJarForPublication

jar {
    archiveClassifier = "dev"
}

//sourcesJar {
//    afterEvaluate {
//        [":common"].forEach {
//            def depSources = project(it).sourcesJar
//            dependsOn depSources
//            from(depSources.archiveFile.map { zipTree(it) }) {
//                exclude "architectury.accessWidener"
//            }
//        }
//    }
//}

components.java {
    withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
        skip()
    }
}
